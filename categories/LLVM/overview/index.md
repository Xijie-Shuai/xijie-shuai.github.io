---
layout: default
title: 概述
---

# 概述

## 编译器架构范式

目前流行的编译器通架构为**前端**、**中端**和**后端**组成的**三段式架构**。

![popular_compiler_arch](images/popular_compiler_arch.png){: width="65%"}

**前端**：将用高级编程语言编写的源代码解析成更便于进行编译优化和目标代码生成的一种中间表示，并检查输入代码的**词法**、**语法**、**语义**合法。不同高级编程语言编写的源代码可以转为统一的中间表示，以使后续的流程可以和语言无关。

什么是词法、语法、语义？

- 词法分析(Lexical Analysis)：将源代码转换为Token序列，以识别关键字、标识符、常量、运算符等基本单元。例如`int x = 42;`分析结果为：`int→关键字`，`x→标识符`，`=→运算符`，`42→整数常量`，`;→分号`。当源代码中包含无法识别的字符或非法记号时，即词法不合法(Lexical Error)，例如`int x = 10$;`。
- 语法分析(Syntax Analysis)：根据语言的语法规则构建抽象语法树语法树(Abstract Syntax Tree, AST)，以检查语句结构是否符合语言规范。一个简单的例子：`int x = 42;`会构建如下结构。当代码结构不符合语言的语法规则，例如`int = x 10;`时，语法分析器无法构建合法的语法树(Syntax Error)。
```text
Declaration
├── Type: int
├── Identifier: x
└── Initializer: 42
```
- 语义分析(Semantic Analysis)：检查语法树的语义正确性，如类型匹配、作用域、变量是否已定义等，以确保程序逻辑合理。例如`int x = "hello";`语法合法但语义分析会报错(Semantic Error)，因为int类型不能赋值为字符串。

**中端**：进行编译优化，提升程序的性能。中端常见的优化有常量传播、死代码消除、循环不变代码外提、循环展开等。通常提到的优化都是语言、目标架构无关的优化，但现实中也存在语言、架构相关的优化。

**后端**：针对目标硬件硬件，将中端输出的IR翻译成对应的机器码。通常包括指令选择、指令调度、寄存器分配和机器码生成等。

## LLVM的子工具

LLVM编译器整体架构采用的就是如上的三段式。LLVM编译器生态是一系列“驱动”与“工具”的集合。其中:
- Clang Driver：即`clang`命令，是LLVM C/C++的原生编译器（也可以说是编译流程的顶层驱动），接收用户在命令行的所有参数，并依次调用一系列解耦的前（`cc1`）、中（`opt`）、后（`llc`）端，汇编器（汇编语言源文件转二进制机器指令目标文件，如`as`），链接器（把多个目标文件、静态/动态库合并成最终的可执行文件或共享库，如`ld`）等子驱动或工具
- `cc1`：Clang前端，即一种前端的实现，对应内部模块`cc1`，可以用`clang -cc1`直接、独立地调用clang前端并生成AST或LLVM IR（取决于具体命令行选项）
- LLVM Core：LLVM核心库，围绕LLVM IR构建的一系列优化器、目标平台代码生成器的集合
- `opt`：LLVM的中端驱动，接受`.bc`或`.ll`格式的LLVM IR，串联各种Pass。内部通过PassManager调用LLVM核心库里的的各种Pass
- `llc`：包装了LLVM核心库后端功能的工具。它接受经过优化的LLVM IR，实现IR到目标架构机器码（或汇编）的转换

