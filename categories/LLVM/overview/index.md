---
layout: default
title: 概述
---

# 概述

## 编译器架构范式

目前流行的编译器通架构为**前端**、**中端**和**后端**组成的**三段式架构**。

![popular_compiler_arch](images/popular_compiler_arch.png){: width="65%"}

**前端**：将用高级编程语言编写的源代码解析成更便于进行编译优化和目标代码生成的一种中间表示，并检查输入代码的**词法**、**语法**、**语义**合法。不同高级编程语言编写的源代码可以转为统一的中间表示，以使后续的流程可以和语言无关。

什么是词法、语法、语义？

- 词法分析(Lexical Analysis)：将源代码转换为Token序列，以识别关键字、标识符、常量、运算符等基本单元。例如`int x = 42;`分析结果为：`int→关键字`，`x→标识符`，`=→运算符`，`42→整数常量`，`;→分号`。当源代码中包含无法识别的字符或非法记号时，即词法不合法(Lexical Error)，例如`int x = 10$;`。
- 语法分析(Syntax Analysis)：根据语言的语法规则构建抽象语法树语法树(Abstract Syntax Tree, AST)，以检查语句结构是否符合语言规范。一个简单的例子：`int x = 42;`会构建如下结构。当代码结构不符合语言的语法规则，例如`int = x 10;`时，语法分析器无法构建合法的语法树(Syntax Error)。
```text
Declaration
├── Type: int
├── Identifier: x
└── Initializer: 42
```
- 语义分析(Semantic Analysis)：检查语法树的语义正确性，如类型匹配、作用域、变量是否已定义等，以确保程序逻辑合理。例如`int x = "hello";`语法合法但语义分析会报错(Semantic Error)，因为int类型不能赋值为字符串。

**中端**：进行编译优化，提升程序的性能。中端常见的优化有常量传播、死代码消除、循环不变代码外提、循环展开等。通常提到的优化都是语言、目标架构无关的优化，但现实中也存在语言、架构相关的优化。

**后端**：针对目标硬件硬件，将中端输出的IR翻译成对应的机器码。通常包括指令选择、指令调度、寄存器分配和机器码生成等。

## LLVM的子工具

LLVM整体架构采用的就是如上的三段式。LLVM编译流程的子工具中，`clang`对应前端，`opt`对应中端，`llc`对应后端。`clang`在实际LLVM编译中也承担驱动的角色，即`clang`可分为clang frontend(对应内部模块`cc1`，可以用`clang -cc1`直接、独立地调用LLVM前端)，和clang driver(即直接使用`clang`，它作为驱动会调用`cc1`，`opt`，`llc`，连接器`ld.lld`等)。
