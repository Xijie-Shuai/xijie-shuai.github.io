---
layout: default
title: 基本块和控制流图
---

# 基本块和控制流图

## 控制流图(Control Flow Graph, CFG)
现代主流编译器基本上都是基于CFG和静态单赋值(Static Single Assignment, SSA)。接下来两小节分别介绍二者。

逻辑上每个算子或者指令都有输入/输出，各输入输出互相衔接，构成图(Graph)。为了着重强调控制流的影响，并简化图的结构，CFG首先把代码划分成基本块(Basic Block, BB)，并将基本块作为CFG的节点，而边则描述了基本块之间的执行顺序（包括跳转关系）。

<img src="_images/graph_IR.png" width=50% />

## 基本块

基本块指一段尽可能长的连续执行的指令序列，s.t.这段指令序列只能从第一行指令开始执行且除最后一条指令外，指令序列中不包含分支、跳转、终止指令。

更具体地，当遇到以下指令时会产生一个新的基本块:

- 过程和函数（区别在于无和有返回值）入口点
- 跳转或分支的目标指令
- 条件分支之后的直通(fallthrough)指令（可以理解为例如A; if(...){B}; C中，如果if不执行，则A会直通到C，C也会成为新的基本块的开始）
- 引发异常的指令之后的指令（即一段指令序列中可能抛出异常的位置。虽然高级语言中try{...}catch{...}等用法看起来try中处处都可能抛出异常，但在编译器中真正可能抛出异常的原子指令只有a.显示的RAISE/throw，和b.用户函数调用。其他算数、内存访问要么在前端被检测和拆分，例如a/b可以拆分成除法+异常检查，要么就不拆分基本块，例如C/C++中有符号整数溢出、除0、非法移位、数组越界访问、空指针解引用、使用未初始化的值、访问已销毁的变量、重复释放同一内存等未定义行为(Undefined Behavior, UB)就不会成为基本块的边界）
- 异常处理程序的起始指令

而一个基本块的结束指令可能是：

- 直接和间接的无条件和条件分支指令
- 可能引发异常的指令
- return指令（过程虽然没有返回值但也有ret)
- 如果函数调用不能返回，用于抛出异常的函数或特殊调用指令，如C中的longjmp和exit

值得注意的是，基本块都是在过程和函数内部划分的，因此其内的第一条/最后一条指令必定是某基本块的边界指令。但调用函数的位置不一定会是边界指令，调用指令只是一条普通指令，算完后会接着执行下一条，和其他普通指令没什么区别。

通常编译器会先将高级语言转化为IR后再划分基本块，主要原因是高级语言中一行代码包含的信息比较多，需要先做拆分。

